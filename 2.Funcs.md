# Topics Covered:
### [**1. If/Else**](#ifelse) : Block of code that exeutes under specified conditions
### [**2. Switch**](#switch) : Single statement - multiple ways to execute
### [**3. Do/While Loops**](#whileloop) : Executing code while some conditions are true
### [**4. For Loop**](#forloop) : Executing code for ** loop times when some conditions are true
### [**5. Functions**](#func) : Creating repeating programms
### [**6. Functions Paremeters**](#funcparam) : Variables of functions
### [**7. Functions Overloading**](#funcover) : Overloading of funtions
### [**8. Scopes**](#scopes) : Global variables
### [**9. Recursion**](#recur) : Repeatable functions
### [**10. Lambda**](#lam) : Short-hand functions 
##
<a name="ifelse" ></a>
# 1. If / Else
Use '**if**' to specify a block of code to be executed, if a condition is true
####
Use '**else**' to specify a block of code to be executed, if the same condition is false
####
Use '**else**' if to specify a new condition to test, if the none of previous conditions true
```cpp
int number_one = 10, number_two = 20, number_three = 30;
/* Syntax
    if(condition 1){
    --code--
    }
    else if(condition 2){
    --code--
    }
    else if(condition 3){
    --code--
    }
    else{
    --code--
    }
*/
    if(number_one > 15){
        cout << "number one greater than 15"<< endl;
    }
    else if(number_one > number_two){
        cout << "number one is greater than number two" << endl;
    }
    else{
        number_one = number_one + 100;
        cout << "number one was small, so now its value increased with 100" << endl;
    }
    // OR
    bool cond = number_one > number_two;
    if( cond){ ... }
    else { ... }
```
There is short hand syntax for one statement versions of if/else
```cpp
/* Syntax
if(expression) --statement--;
else if (expression) --statement--;
else --statement--;
*/
if( 5> 10) cout << "5 > 10";
else cout << "5 < 10";
```
Since here we work with conditions we can use logical operators like &&-AND , ||- OR, !- NOT
```cpp
// if( condition_1 && condition_2) ...
// else if (condition_1 != condition_2) ...

if( a<=10 && a>=0) cout << " 'a' is from 0 to 10;
else if(a <0 || a>10) cout << "'a' is out of range (0,10);
```
<a name="switch" ></a>
# 2. Switch
Use the **switch** statement to select one of many code blocks to be executed.
```cpp
/* Syntax
switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}
*/
// Weather teller
string weather_tell;
    cout << "Enter weather type(sunny,cloudy,rain,fog): ";
    cin >> weather_tell;
    switch (weather_tell)
    {
    case "sunny":
        cout << "Sunny - weather without rain and precipitations\n";
        break;
    case "cloudy":
        cout << "Cloudy - weather without sun rays and plenty of clouds\n";
        break;
    case "rain":
        cout << "Rain - weather when water drops from clouds\n";
        break;
    case "fog":
        cout << "Fog - Small vision because of high moisture\n";
        break;
    
    default:
        cou << "You entered wrong weather type, try again!\n";
        break;
    }
```
OR
```cpp
int day = 4;
switch (day) {
  case 1:
    cout << "Monday";
    break;
  case 2:
    cout << "Tuesday";
    break;
  case 3:
    cout << "Wednesday";
    break;
  case 4:
    cout << "Thursday";
    break;
  case 5:
    cout << "Friday";
    break;
  case 6:
    cout << "Saturday";
    break;
  case 7:
    cout << "Sunday";
    break;
}
```
case (expression) - block of code that runs under certain 'expression'
break - stops code, so other choices won't run
default - runs when none of other cases compiles

<a name="whileloop" ></a>
# 3. Do/While Loops
Loops can execute a block of code as long as a specified condition is reached.
###
Loops are handy because they save time, reduce errors, and they make code more readable.
###
The while loop loops through a block of code as long as a specified condition is true:
```cpp
/* Syntax
while (condition) {
  // code block to be executed
}
*/
int i = 0;
while (i < 5) {
  cout << i << "\n";
  i++;
}
```
## Do while
The do/while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true. Then it will repeat the loop as long as the condition is true.
```cpp
/* Syntax
do {
  // code block to be executed
}
while (condition);
*/
int i = 0;
do {
  cout << i << "\n";
  i++;
}while (i < 5);
```
<a name="forloop" ></a>
# 4. For Loops
When you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop:
```cpp
/*
for (statement 1; statement 2; statement 3) {
  // code block to be executed
}
*/
for (int i = 0; i < 5; i++) {
  cout << i << "\n";
}
```
#### •Statement 1: is executed (one time) before the execution of the code block.
Statement 1 sets a variable before the loop starts: int i = 0
#### •Statement 2: defines the condition for executing the code block.
Statement 2 defines the condition for the loop to run: i < 5. If the condition is true, the loop will start over again, if it is false, the loop will end.
#### •Statement 3: is executed (every time) after the code block has been executed.
Statement 3 increases a value each time the code block in the loop has been executed: i++
```cpp
// Examples of for loop usage
// 1. Print Even Numbers
for (int i = 0; i <= 10; i = i + 2) {
  cout << i << "\n";
}
// 2. Sum of Numbers
int sum = 0;
for (int i = 1; i <= 5; i++) {
  sum = sum + i;
}
cout << "Sum is " << sum;
```

## Nested For Loop
When there is one loop inside of another its called, nested loop
```cpp
// If else nested
cout << " Enter number: ";
int n;
cin >> n;
if(n>0){
    cout << " number is positive\n";
    if(n>10){
        cout << " number also greater than 10\n";
    }
}
else if (n == 0) cout << " number is 0\n";
else cout << " number is negative\n";

// While Nested
int mark = 0;
bool checked = false;
while( checked == false){
    mark +=1;
    while(mark == 10){
        checked = true;
    }
}

// Nested For Loop
// 1. Multiplication Table example
for (int i = 1; i <= 3; i++) {
  for (int j = 1; j <= 3; j++) {
    cout << i * j << " ";
  }
  cout << "\n";
}
/* Result:
1 2 3
2 4 6
3 6 9
*/
// 2. Geometric Figures
int size=5;
int spaces = size-1;
for(int i=1; i <=size; i++){
    for(int z=spaces; z >0; z--){
        cout<< ' ';
    }
    spaces--;
    for(int j = 1; j <i*2; j++){
        cout << '*';
    }
cout << endl;
}
/* Result:
    *
   ***
  *****
 *******
*********
```
## Foreach Loop
There is also a "for-each loop" (also known as ranged-based for loop), which is used to loop through elements in an array (or other data structures):
####
Array is simply list of variables
####
Sadly changes of elements do not save out of loop
```cpp
/* Syntax
for (type variableName : arrayName) {
  // code block to be executed
}
*/
// Example with array
int myNumbers[5] = {10, 20, 30, 40, 50};
for (int num : myNumbers) {
  cout << num*10 << ' ';
}
/*Result: 100 200 300 400 500
  But myNumbers still = {10,20,30,40,50} */

// Example with string
string word = "Hello";
for (char c : word) {
  cout << c << " ";
}
// Result: H e l l o
// Same result with C-style string: char word[]= "Hello";
```
## Break and Continiue
Break means for compiler "full stop the block of code( if/else, while, and etc.)
####
Continiue means "just skip this one, and move to next"
```cpp
// While Loop (Break)
int i = 0;
while (i < 10) {
  cout << i << "\n";
  i++;
  if (i == 4) {
    break;
  }
}
// While Loop (Cont)
int i = 0;
while (i < 10) {
  if (i == 4) {
    i++;
    continue;
  }
  cout << i << "\n";
  i++;
}
// For Loop (Cont)
for (int i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  cout << i << "\n";
}
// For Loop (Break)
for (int i = 0; i < 10; i++) {
  if (i == 4) {
    break;
  }
  cout << i << "\n";
}
```
<a name="func" ></a>
# 5. Functions
A *function* is a block of code which only runs when it is called. You can pass data, known as *parameters*, into a function. Functions are used to perform certain actions, and they are important for reusing code: *Define the code once, and use it many times*.
###
C++ provides some pre-defined functions, such as *main()*, which is used to execute code. But you can also create your own functions to perform certain actions.
###
To create (often referred to as declare) a function, specify the name of the function, followed by parentheses ():
```cpp
/* Syntax
void myFunction() {
  // code to be executed
} */
//Example: Hello World Function
void HelloFunc(){
    cout << "Hello World";
}
int main(){
    HelloFunc(); //Hello World
    HelloFunc(); //Hello World
    HelloFunc(); //Hello World
    return 0;
}
```
#### myFunction() - is the name of the function.
#### void - means that the function does not have a return value. You will learn more about return values later in the next chapter inside the function (the body), add code that defines what the function should do.

## Declaration and Definition
You can declare func before *main()* and after it give definition
```cpp

void Hello();

int main(){
    Hello();
    return 0;
}
void Hello(){
    cout << "Hello World";
    }
```
If you don't declare first, compiler will give an error


<a name="funcparam" ></a>
# 6. Functions Paremeters
Information can be passed to functions as a parameter. Parameters act as variables inside the function.
###
Parameters are specified after the function name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma:
```cpp
/* Syntax
void functionName(parameter1, parameter2, parameter3) {
  // code to be executed
}*/

void myFunction(string fname) {
  cout << fname << " Refsnes\n";
}

int main() {
  myFunction("Liam"); // Liam Refsnes
  return 0;
}
```
## Default Parameters
You can also use a default parameter value, by using the equals sign (=).
###
If we call the function without an argument, it uses the default value ("Norway"):
```cpp
void myFunction(string country = "Norway") {
  cout << country << "\n";
}

int main() {
  myFunction("Sweden");
  myFunction();
  return 0;
}

// Sweden
// Norway
```
## Multiple Parameters
You can pass multiple parameters at once
```cpp
void myFunction(string fname, int age) {
  cout << fname << " Refsnes. " << age << " years old. \n";
}

int main() {
  myFunction("Liam", 3);
  myFunction("Jenny", 14);
  return 0;
}

// Liam Refsnes. 3 years old.
// Jenny Refsnes. 14 years old.
```
## Return Value
The void keyword, used in the previous examples, indicates that the function should not return a value. If you want the function to return a value, you can use a data type (such as int, string, etc.) instead of void, and use the return keyword inside the function:
```cpp
int myFunction(int x, int y) {
  return x + y;
}

int main() {
  cout << myFunction(5, 3);
  return 0;
}

// Outputs 8 (5 + 3)
```
Difference
```cpp
void Sum(int a, int b){ cout << a+b;}
int Sumup( int a, int b) {return a+b;}

int main(){
    Sum(5,6); // 11
    cout << Sumup(5,6); // 11
    return 0;
}
```
## Pass by Reference
In given functions above we don't change passed parameter, but with operator *&* it is possible.
###
This can be useful when you need to change the value of the argument(s):
```cpp
void changeValue(int &num) {
  num = 50;
}

int main() {
  int value = 10;
  changeValue(value);  // Call the function and change the value to 50
  cout << value; 
  return 0;
}
```
<a name="funcover" ></a>
# 7. Functions Overloading
**Function overloading** allows multiple functions to have the same name, as long as their parameters are different in *type* or *number*:
```
int myFunction(int x)
float myFunction(float x)
double myFunction(double x, double y)
```
This lets you use the same function name for similar tasks.
### Without Overloading
Consider the following example, which have two functions that add numbers of different type:
```cpp
int plusFuncInt(int x, int y) {
  return x + y;
}

double plusFuncDouble(double x, double y) {
  return x + y;
}

int main() {
  int myNum1 = plusFuncInt(8, 5);
  double myNum2 = plusFuncDouble(4.3, 6.26);

  cout << "Int: " << myNum1 << "\n";
  cout << "Double: " << myNum2;
  return 0;
}
```
**Problem**: We had to create two different function names for the same logic.
### With Overloading
```cpp
int plusFunc(int x, int y) {
  return x + y;
}

double plusFunc(double x, double y) {
  return x + y;
}

int main() {
  int myNum1 = plusFunc(8, 5);
  double myNum2 = plusFunc(4.3, 6.26);

  cout << "Int: " << myNum1 << "\n";
  cout << "Double: " << myNum2;
  return 0;
}
```
OR When there are different number of parameters
```cpp
int plusFunc(int x, int y) {
  return x + y;
}

int plusFunc(int x, int y, int z) {
  return x + y + z;
}

int main() {
  int result1 = plusFunc(3, 7);
  int result2 = plusFunc(1, 2, 3);

  cout << "Sum of 2 numbers: " << result1 << "\n";
  cout << "Sum of 3 numbers: " << result2;
  return 0;
}
```
<a name="scopes" ></a>
# 8. Scopes(Global Data)
Now that you understand how functions work, it is important to learn how variables act inside and outside of functions.
###
In C++, variables are only accessible inside the region they are created. This is called **scope**.
### Local Scope
```cpp
void myFunction() {
  int x = 5;
  cout << x;
}

int main() {
  myFunction(); // 5
  return 0;
}
```
#### ERROR!!!
```cpp
void myFunction() {
  int x = 5;
}

int main() {
  myFunction();
  cout << x; // Error
  return 0;
}
```
### Global Scope
```cpp
int x = 5;  // Global variable x

void myFunction() {
  // We can use x here
  cout << x << "\n"; // 5
}

int main() {
  myFunction();
  // We can also use x here

  cout << x; // 5
  return 0;
}
```
A variable created outside of a function, is called a **global variable** and belongs to the *global scope*.
###
If you operate with the same variable name inside and outside of a function, C++ will treat them as two separate variables; One available in the global scope (outside the function) and one available in the local scope (inside the function):
```cpp
// Global variable x
int x = 5;

void myFunction() {
  // Local variable with the same name as the global variable (x)
  int x = 22;
  cout << x << "\n"; // Refers to the local variable x
}

int main() {
  myFunction();

  cout << x; // Refers to the global variable x
  return 0;
}
```
##### However, you should avoid using the same variable name for both globally and locally variables as it can lead to errors and confusion.

##### In general, you should be careful with global variables, since they can be accessed and modified from any function:
```cpp
// Global variable x
int x = 5;

void myFunction() {
  cout << ++x << "\n"; // Increment the value of x by 1 and print it
}

int main() {
  myFunction();

  cout << x; // Print the global variable x
  return 0;
}

// The value of x is now 6 (no longer 5)
```
<a name="recur" ></a>
# 9. Recursion
Recursion is the technique of making a function call itself.
###
This technique provides a way to break complicated problems down into simple problems which are easier to solve.
###
Recursion may be a bit difficult to understand. The best way to figure out how it works is to experiment with it.
```cpp
int sum(int k) {
  if (k > 0) {
    return k + sum(k - 1);
  } else {
    return 0;
  }
}

int main() {
  int result = sum(10);
  cout << result;
  return 0;
}
```
When the *sum()* function is called, it adds parameter k to the sum of all numbers smaller than k and returns the result. When k becomes 0, the function just returns 0. When running, the program follows these steps:
```txt
10 + sum(9)
10 + ( 9 + sum(8) )
10 + ( 9 + ( 8 + sum(7) ) )
...
10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + sum(0)
10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0
```
<a name="lam" ></a>
# 10. Lambda
A lambda function is a small, anonymous function you can write directly in your code. It's useful when you need a quick function without naming it or declaring it separately.
###
Think of it as a "mini function on the fly."
```cpp
/* Syntax
[capture] (parameters) { code };
*/

int main() {
  auto message = []() {
    cout << "Hello World!\n"; 
  };

  message(); // Hello World
  return 0;
}
```
**capture** - part that takes parameters outside of code
**parameters** - You can pass values into a lambda just like a regular function:
**code** - programme code
## Lambda with Parameters
You can pass parameters and use 'return' as well:
```cpp
#include <iostream>
using namespace std;

int main() {
  auto add = [](int a, int b) {
    return a + b;
  };

  cout << add(3, 4);
  return 0;
}
```
## Lambda with Capture
You can use the [ ] brackets to give a lambda access to variables outside of it. This is called the **capture clause**.
```cpp
int main() {
  int x = 10;
  auto show = [x]() {
    cout << x;
  };

  show(); // 10
  return 0;
}
```
##
```cpp
int main(){
    bool fact = true;
    auto message[ fact ](int a, int b){
        if(a>b == fact) cout << a << "is greater than " << b << endl;
        else if(a>b != fact) cout << b << "is greater than " << a << endl;
        else cout << "incorrect input \n";
    }
    int num1,num2;
    cout << "Number 1: "; cin >> num1; // 50
    cout << "Number 2: "; cin >> num2; // 4
    message(num1,num2); // 50 is greater than 4
    return 0;
}
```
Here *fact* was taken directly from outside without entering it
###
*num1* and *num2* were given in code
###
and code auto-matically run like function

## Lambda in functions
You can also pass a lambda function as an argument to another function.
###
This is useful when you want to tell a function what to do, not just what data to use.
###
In the example below, we send a small lambda function to another function, which then runs it twice:
```cpp
#include <iostream>
#include <functional> // Needed for std::function
using namespace std;

// A function that takes another function as parameter
void myFunction(function<void()> func) {
  func();
  func();
}

int main() {
  auto message = []() {
    cout << "Hello World!\n";
  };

  myFunction(message);
  return 0;
}
```
